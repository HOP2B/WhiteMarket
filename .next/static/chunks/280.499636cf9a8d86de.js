"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[280,899],{6280:(e,t,n)=>{n.r(t),n.d(t,{createOrReadKeyless:()=>A,removeKeyless:()=>N,safeParseClerkFile:()=>k});var r=n(3581),o=n(1837),s=n(7696),l=n(5364);async function u(){var e,t,n,r,o,u;let c=await (0,s.headers)();return{nodeVersion:l.version,nextVersion:function(){var e;try{return null!=(e=l.title)?e:"unknown-process-title"}catch{return}}(),npmConfigUserAgent:l.env.npm_config_user_agent,userAgent:null!=(e=c.get("User-Agent"))?e:"unknown user-agent",port:l.env.PORT,host:null!=(t=c.get("host"))?t:"unknown host",xPort:null!=(n=c.get("x-forwarded-port"))?n:"unknown x-forwarded-port",xHost:null!=(r=c.get("x-forwarded-host"))?r:"unknown x-forwarded-host",xProtocol:null!=(o=c.get("x-forwarded-proto"))?o:"unknown x-forwarded-proto",xClerkAuthStatus:null!=(u=c.get("x-clerk-auth-status"))?u:"unknown x-clerk-auth-status",isCI:function(){let e=new Set(["","false","0","no"]);return i.some(t=>{let n=l.env[t];if(void 0===n)return!1;let r=n.trim().toLowerCase();return!e.has(r)})}()}}let i=["CI","CONTINUOUS_INTEGRATION","BUILD_NUMBER","BUILD_ID","BUILDKITE","CIRCLECI","GITHUB_ACTIONS","GITLAB_CI","JENKINS_URL","TRAVIS","APPVEYOR","WERCKER","DRONE","CODESHIP","SEMAPHORE","SHIPPABLE","TEAMCITY_VERSION","BAMBOO_BUILDKEY","GO_PIPELINE_NAME","TF_BUILD","SYSTEM_TEAMFOUNDATIONCOLLECTIONURI","BITBUCKET_BUILD_NUMBER","HEROKU_TEST_RUN_ID","VERCEL","NETLIFY"];async function c(e){let t=new Headers;return e.nodeVersion&&t.set("Clerk-Node-Version",e.nodeVersion),e.nextVersion&&t.set("Clerk-Next-Version",e.nextVersion),e.npmConfigUserAgent&&t.set("Clerk-NPM-Config-User-Agent",e.npmConfigUserAgent),e.userAgent&&t.set("Clerk-Client-User-Agent",e.userAgent),e.port&&t.set("Clerk-Node-Port",e.port),e.host&&t.set("Clerk-Client-Host",e.host),e.xPort&&t.set("Clerk-X-Port",e.xPort),e.xHost&&t.set("Clerk-X-Host",e.xHost),e.xProtocol&&t.set("Clerk-X-Protocol",e.xProtocol),e.xClerkAuthStatus&&t.set("Clerk-Auth-Status",e.xClerkAuthStatus),e.isCI&&t.set("Clerk-Is-CI","true"),t}let a=".clerk",d="clerk.lock",f=(...e)=>{let t=(0,o.dc)(),n=(0,o.y4)();return t.join(n(),a,...e)},C=".tmp",I=()=>f(C,"keyless.json"),g=!1;function k(){let{readFileSync:e}=(0,o.p8)();try{let t,n=I();try{t=e(n,{encoding:"utf-8"})||"{}"}catch{t="{}"}return JSON.parse(t)}catch{return}}let h=()=>{let{writeFileSync:e}=(0,o.p8)();g=!0,e(d,"This file can be deleted. Please delete this file and refresh your application",{encoding:"utf8",mode:"0777",flag:"w"})},E=()=>{let{rmSync:e}=(0,o.p8)();try{e(d,{force:!0,recursive:!0})}catch{}g=!1},p=()=>{let{existsSync:e}=(0,o.p8)();return g||e(d)};async function A(){let{writeFileSync:e,mkdirSync:t}=(0,o.p8)();if(p())return null;h();let n=I(),s=f(C,"README.md");t(f(C),{recursive:!0}),function(){let{existsSync:e,writeFileSync:t,readFileSync:n,appendFileSync:r}=(0,o.p8)(),s=(0,o.dc)(),l=(0,o.y4)(),u=s.join(l(),".gitignore");e(u)||t(u,""),n(u,"utf-8").includes(a+"/")||r(u,`
# clerk configuration (can include secrets)
/${a}/
`)}();let l=k();if((null==l?void 0:l.publishableKey)&&(null==l?void 0:l.secretKey))return E(),l;let i=(0,r.n)({}),d=await u().then(c).catch(()=>new Headers),g=await i.__experimental_accountlessApplications.createAccountlessApplication({requestHeaders:d}).catch(()=>null);return g&&(e(n,JSON.stringify(g),{encoding:"utf8",mode:"0777",flag:"w"}),e(s,`
## DO NOT COMMIT
This directory is auto-generated from \`@clerk/nextjs\` because you are running in Keyless mode. Avoid committing the \`.clerk/\` directory as it includes the secret key of the unclaimed instance.
  `,{encoding:"utf8",mode:"0777",flag:"w"})),E(),g}function N(){let{rmSync:e}=(0,o.p8)();if(!p()){h();try{e(f(),{force:!0,recursive:!0})}catch{}E()}}}}]);